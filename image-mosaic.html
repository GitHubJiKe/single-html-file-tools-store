<!-- å›¾ç‰‡é©¬èµ›å…‹å¤„ç†å·¥å…·ï¼ˆå•æ–‡ä»¶HTMLå®ç°ï¼Œæ— éœ€æ„å»ºæ­¥éª¤ï¼‰-->
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å›¾ç‰‡é©¬èµ›å…‹å¤„ç†å·¥å…·</title>
  <link rel="icon" type="image/x-icon" href="./favicon.ico">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    /* å¤´éƒ¨ */
    .header {
      text-align: center;
      color: white;
      margin-bottom: 30px;
    }
    .header h1 {
      font-size: 36px;
      margin-bottom: 10px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    .header p {
      font-size: 16px;
      opacity: 0.9;
    }
    
    /* ä¸»å†…å®¹åŒº */
    .main-content {
      background: white;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      overflow: hidden;
    }
    
    /* å·¥å…·æ  */
    .toolbar {
      background: #f8f9fa;
      padding: 20px;
      border-bottom: 1px solid #e9ecef;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      align-items: center;
    }
    
    .tool-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .tool-group label {
      font-size: 14px;
      font-weight: 600;
      color: #495057;
    }
    
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }
    
    .btn-secondary {
      background: #6c757d;
      color: white;
    }
    .btn-secondary:hover {
      background: #5a6268;
    }
    
    .btn-success {
      background: #28a745;
      color: white;
    }
    .btn-success:hover {
      background: #218838;
    }
    
    .btn-danger {
      background: #dc3545;
      color: white;
    }
    .btn-danger:hover {
      background: #c82333;
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-toggle {
      background: #e9ecef;
      color: #495057;
    }
    
    .btn-toggle.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    input[type="file"] {
      display: none;
    }
    
    select, input[type="range"] {
      padding: 8px 12px;
      border: 1px solid #ced4da;
      border-radius: 6px;
      font-size: 14px;
      background: white;
      cursor: pointer;
    }
    
    input[type="range"] {
      width: 150px;
    }
    
    .size-display {
      font-size: 14px;
      font-weight: 600;
      color: #667eea;
      min-width: 40px;
    }
    
    /* ç”»å¸ƒåŒºåŸŸ */
    .canvas-container {
      padding: 40px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 500px;
      background: #f8f9fa;
      position: relative;
    }
    
    .empty-state {
      text-align: center;
      color: #6c757d;
    }
    
    .empty-state-icon {
      font-size: 64px;
      margin-bottom: 20px;
      opacity: 0.5;
    }
    
    .empty-state h3 {
      font-size: 20px;
      margin-bottom: 10px;
      color: #495057;
    }
    
    .empty-state p {
      font-size: 14px;
      color: #6c757d;
    }
    
    #canvas {
      max-width: 100%;
      max-height: 70vh;
      box-shadow: 0 5px 20px rgba(0,0,0,0.1);
      cursor: crosshair;
      display: none;
    }
    
    #canvas.active {
      display: block;
    }
    
    /* è¯´æ˜åŒºåŸŸ */
    .instructions {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 8px;
      padding: 15px;
      margin: 20px;
      display: none;
    }
    
    .instructions.active {
      display: block;
    }
    
    .instructions h4 {
      font-size: 14px;
      color: #856404;
      margin-bottom: 8px;
    }
    
    .instructions ul {
      list-style: none;
      padding-left: 0;
    }
    
    .instructions li {
      font-size: 13px;
      color: #856404;
      margin-bottom: 5px;
      padding-left: 20px;
      position: relative;
    }
    
    .instructions li:before {
      content: "â€¢";
      position: absolute;
      left: 5px;
    }
    
    /* Toast æç¤º */
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
      z-index: 1000;
      opacity: 0;
      transform: translateX(400px);
      transition: all 0.3s;
      font-size: 14px;
      max-width: 300px;
    }
    
    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }
    
    .toast.success {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    }
    
    .toast.error {
      background: linear-gradient(135deg, #dc3545 0%, #e83e8c 100%);
    }
    
    /* ç§»åŠ¨ç«¯é€‚é… */
    @media (max-width: 768px) {
      .header h1 {
        font-size: 24px;
      }
      .toolbar {
        flex-direction: column;
        align-items: stretch;
      }
      .tool-group {
        flex-direction: column;
        align-items: stretch;
      }
      .btn {
        justify-content: center;
      }
      .canvas-container {
        padding: 20px;
        min-height: 300px;
      }
      input[type="range"] {
        width: 100%;
      }
    }
    
    /* é€‰åŒºæ ·å¼ */
    .selection-overlay {
      position: absolute;
      border: 2px dashed #667eea;
      background: rgba(102, 126, 234, 0.1);
      pointer-events: none;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- å¤´éƒ¨ -->
    <div class="header">
      <h1>ğŸ¨ å›¾ç‰‡é©¬èµ›å…‹å¤„ç†å·¥å…·</h1>
      <p>ä¸Šä¼ å›¾ç‰‡ï¼Œé€‰æ‹©åŒºåŸŸï¼Œæ·»åŠ é©¬èµ›å…‹æ•ˆæœ</p>
    </div>
    
    <!-- ä¸»å†…å®¹ -->
    <div class="main-content">
      <!-- å·¥å…·æ  -->
      <div class="toolbar">
        <div class="tool-group">
          <label for="uploadBtn">ğŸ“ å›¾ç‰‡æ“ä½œ</label>
          <button class="btn btn-primary" id="uploadBtn" onclick="document.getElementById('imageInput').click()">
            ä¸Šä¼ å›¾ç‰‡
          </button>
          <input type="file" id="imageInput" accept="image/*">
        </div>
        
        <div class="tool-group">
          <label>ğŸ”· é€‰åŒºå½¢çŠ¶</label>
          <button class="btn btn-toggle active" id="shapeRectBtn" onclick="setSelectionShape('rect')">
            â–¢ çŸ©å½¢
          </button>
          <button class="btn btn-toggle" id="shapeCircleBtn" onclick="setSelectionShape('circle')">
            â— åœ†å½¢
          </button>
        </div>
        
        <div class="tool-group">
          <label>ğŸ”„ é€‰ä¸­æ¨¡å¼</label>
          <button class="btn btn-toggle" id="invertBtn" onclick="toggleInvert()">
            ğŸ”€ åå‘é€‰ä¸­
          </button>
        </div>
        
        <div class="tool-group">
          <label>ğŸ­ é©¬èµ›å…‹ç±»å‹</label>
          <select id="mosaicType">
            <option value="pixelate">åƒç´ åŒ–</option>
            <option value="blur">æ¨¡ç³Š</option>
            <option value="glass">æ¯›ç»ç’ƒ</option>
            <option value="grid">ç½‘æ ¼</option>
          </select>
        </div>
        
        <div class="tool-group">
          <label>ğŸ“ é©¬èµ›å…‹å¤§å°</label>
          <input type="range" id="mosaicSize" min="5" max="50" value="15" step="1">
          <span class="size-display" id="sizeDisplay">15</span>
        </div>
        
        <div class="tool-group">
          <button class="btn btn-success" id="applyBtn" disabled onclick="applyMosaicToSelection()">
            âœ“ åº”ç”¨é©¬èµ›å…‹
          </button>
          <button class="btn btn-secondary" id="resetBtn" disabled onclick="resetImage()">
            â†» é‡ç½®å›¾ç‰‡
          </button>
          <button class="btn btn-danger" id="downloadBtn" disabled onclick="downloadImage()">
            â¬‡ ä¸‹è½½å›¾ç‰‡
          </button>
        </div>
      </div>
      
      <!-- è¯´æ˜ -->
      <div class="instructions" id="instructions">
        <h4>ğŸ“Œ ä½¿ç”¨è¯´æ˜ï¼š</h4>
        <ul>
          <li>æŒ‰ä½é¼ æ ‡å·¦é”®æ‹–åŠ¨é€‰æ‹©åŒºåŸŸï¼ˆçŸ©å½¢æˆ–åœ†å½¢ï¼‰</li>
          <li>å¼€å¯"åå‘é€‰ä¸­"åï¼Œå°†å¯¹é€‰åŒºä¹‹å¤–çš„åŒºåŸŸåº”ç”¨é©¬èµ›å…‹</li>
          <li>é€‰æ‹©é©¬èµ›å…‹ç±»å‹å’Œå¤§å°ï¼Œç„¶åç‚¹å‡»"åº”ç”¨é©¬èµ›å…‹"</li>
          <li>å¯ä»¥å¤šæ¬¡é€‰æ‹©ä¸åŒåŒºåŸŸæ·»åŠ é©¬èµ›å…‹</li>
          <li>ç‚¹å‡»"é‡ç½®å›¾ç‰‡"å¯ä»¥æ¢å¤åˆ°åŸå§‹å›¾ç‰‡</li>
          <li>å®Œæˆåç‚¹å‡»"ä¸‹è½½å›¾ç‰‡"ä¿å­˜å¤„ç†åçš„å›¾ç‰‡</li>
        </ul>
      </div>
      
      <!-- ç”»å¸ƒåŒºåŸŸ -->
      <div class="canvas-container" id="canvasContainer">
        <div class="empty-state" id="emptyState">
          <div class="empty-state-icon">ğŸ–¼ï¸</div>
          <h3>è¿˜æ²¡æœ‰ä¸Šä¼ å›¾ç‰‡</h3>
          <p>ç‚¹å‡»ä¸Šæ–¹"ä¸Šä¼ å›¾ç‰‡"æŒ‰é’®å¼€å§‹å¤„ç†</p>
        </div>
        <canvas id="canvas"></canvas>
      </div>
    </div>
  </div>
  
  <!-- Toast æç¤º -->
  <div class="toast" id="toast"></div>
  
  <script>
    // å…¨å±€å˜é‡
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageInput = document.getElementById('imageInput');
    const mosaicTypeSelect = document.getElementById('mosaicType');
    const mosaicSizeInput = document.getElementById('mosaicSize');
    const sizeDisplay = document.getElementById('sizeDisplay');
    const applyBtn = document.getElementById('applyBtn');
    const resetBtn = document.getElementById('resetBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const emptyState = document.getElementById('emptyState');
    const instructions = document.getElementById('instructions');
    
    let originalImage = null;
    let currentImageData = null;
    let isSelecting = false;
    let startX = 0;
    let startY = 0;
    let endX = 0;
    let endY = 0;
    let selectionShape = 'rect'; // 'rect' or 'circle'
    let invertSelection = false; // æ˜¯å¦åå‘é€‰ä¸­
    
    // é©¬èµ›å…‹å¤§å°æ˜¾ç¤ºæ›´æ–°
    mosaicSizeInput.addEventListener('input', (e) => {
      sizeDisplay.textContent = e.target.value;
    });
    
    // å›¾ç‰‡ä¸Šä¼ 
    imageInput.addEventListener('change', handleImageUpload);
    
    function handleImageUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      if (!file.type.startsWith('image/')) {
        showToast('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶', 'error');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          originalImage = img;
          loadImage(img);
          showToast('å›¾ç‰‡ä¸Šä¼ æˆåŠŸ', 'success');
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }
    
    // åŠ è½½å›¾ç‰‡åˆ°ç”»å¸ƒ
    function loadImage(img) {
      // è®¡ç®—åˆé€‚çš„ç”»å¸ƒå°ºå¯¸
      const maxWidth = 1200;
      const maxHeight = 800;
      let width = img.width;
      let height = img.height;
      
      if (width > maxWidth) {
        height = (maxWidth / width) * height;
        width = maxWidth;
      }
      
      if (height > maxHeight) {
        width = (maxHeight / height) * width;
        height = maxHeight;
      }
      
      canvas.width = width;
      canvas.height = height;
      
      ctx.drawImage(img, 0, 0, width, height);
      
      // ä¿å­˜å½“å‰å›¾åƒæ•°æ®
      currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      // æ˜¾ç¤ºç”»å¸ƒï¼Œéšè—ç©ºçŠ¶æ€
      emptyState.style.display = 'none';
      canvas.classList.add('active');
      instructions.classList.add('active');
      
      // å¯ç”¨æŒ‰é’®
      applyBtn.disabled = false;
      resetBtn.disabled = false;
      downloadBtn.disabled = false;
    }
    
    // è·å–ç”»å¸ƒåæ ‡ï¼ˆè€ƒè™‘ç¼©æ”¾ï¼‰
    function getCanvasCoordinates(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      const x = (clientX - rect.left) * scaleX;
      const y = (clientY - rect.top) * scaleY;
      
      return { x, y };
    }
    
    // é¼ æ ‡äº‹ä»¶å¤„ç† - é€‰æ‹©åŒºåŸŸ
    canvas.addEventListener('mousedown', (e) => {
      if (!originalImage) return;
      
      const coords = getCanvasCoordinates(e.clientX, e.clientY);
      
      // çŸ©å½¢/åœ†å½¢æ¨¡å¼ï¼šå¼€å§‹æ‹–æ‹½
      startX = coords.x;
      startY = coords.y;
      isSelecting = true;
    });
    
    canvas.addEventListener('mousemove', (e) => {
      const coords = getCanvasCoordinates(e.clientX, e.clientY);
      
      // çŸ©å½¢/åœ†å½¢æ¨¡å¼ï¼šæ‹–æ‹½æ›´æ–°
      if (!isSelecting) return;
      
      endX = coords.x;
      endY = coords.y;
      
      // é‡ç»˜å›¾åƒ
      ctx.putImageData(currentImageData, 0, 0);
      
      // ç»˜åˆ¶é€‰åŒº
      drawSelection(startX, startY, endX, endY);
    });
    
    canvas.addEventListener('mouseup', (e) => {
      if (!isSelecting) return;
      
      const coords = getCanvasCoordinates(e.clientX, e.clientY);
      endX = coords.x;
      endY = coords.y;
      isSelecting = false;
      
      // é‡ç»˜å›¾åƒ
      ctx.putImageData(currentImageData, 0, 0);
      
      // ç»˜åˆ¶æœ€ç»ˆé€‰åŒº
      drawSelection(startX, startY, endX, endY);
    });
    
    // è§¦æ‘¸äº‹ä»¶æ”¯æŒï¼ˆç§»åŠ¨ç«¯ï¼‰
    canvas.addEventListener('touchstart', (e) => {
      if (!originalImage) return;
      e.preventDefault();
      
      const touch = e.touches[0];
      const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
      startX = coords.x;
      startY = coords.y;
      isSelecting = true;
    });
    
    canvas.addEventListener('touchmove', (e) => {
      if (!isSelecting) return;
      e.preventDefault();
      
      const touch = e.touches[0];
      const coords = getCanvasCoordinates(touch.clientX, touch.clientY);
      endX = coords.x;
      endY = coords.y;
      
      ctx.putImageData(currentImageData, 0, 0);
      drawSelection(startX, startY, endX, endY);
    });
    
    canvas.addEventListener('touchend', (e) => {
      if (!isSelecting) return;
      e.preventDefault();
      isSelecting = false;
      
      ctx.putImageData(currentImageData, 0, 0);
      drawSelection(startX, startY, endX, endY);
    });
    
    // è®¾ç½®é€‰åŒºå½¢çŠ¶
    function setSelectionShape(shape) {
      selectionShape = shape;
      document.getElementById('shapeRectBtn').classList.toggle('active', shape === 'rect');
      document.getElementById('shapeCircleBtn').classList.toggle('active', shape === 'circle');
    }
    
    // åˆ‡æ¢åå‘é€‰ä¸­
    function toggleInvert() {
      invertSelection = !invertSelection;
      document.getElementById('invertBtn').classList.toggle('active', invertSelection);
    }
    
    // ç»˜åˆ¶é€‰åŒº
    function drawSelection(x1, y1, x2, y2) {
      ctx.strokeStyle = '#667eea';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      
      if (selectionShape === 'rect') {
        ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
      } else if (selectionShape === 'circle') {
        const centerX = (x1 + x2) / 2;
        const centerY = (y1 + y2) / 2;
        const radiusX = Math.abs(x2 - x1) / 2;
        const radiusY = Math.abs(y2 - y1) / 2;
        
        ctx.beginPath();
        ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
        ctx.stroke();
      }
      
      ctx.setLineDash([]);
      
      // å¦‚æœæ˜¯åå‘é€‰ä¸­ï¼Œæ·»åŠ è§†è§‰æç¤º
      if (invertSelection) {
        ctx.fillStyle = 'rgba(102, 126, 234, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // æ¸…é™¤é€‰åŒºéƒ¨åˆ†
        ctx.globalCompositeOperation = 'destination-out';
        if (selectionShape === 'rect') {
          ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        } else if (selectionShape === 'circle') {
          const centerX = (x1 + x2) / 2;
          const centerY = (y1 + y2) / 2;
          const radiusX = Math.abs(x2 - x1) / 2;
          const radiusY = Math.abs(y2 - y1) / 2;
          
          ctx.beginPath();
          ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
          ctx.fill();
        }
        ctx.globalCompositeOperation = 'source-over';
      }
    }
    
    // åº”ç”¨é©¬èµ›å…‹åˆ°é€‰åŒº
    function applyMosaicToSelection() {
      if (!originalImage) {
        showToast('è¯·å…ˆä¸Šä¼ å›¾ç‰‡', 'error');
        return;
      }
      
      const mosaicType = mosaicTypeSelect.value;
      const mosaicSize = parseInt(mosaicSizeInput.value);
      
      // çŸ©å½¢/åœ†å½¢æ¨¡å¼
      const x = Math.min(startX, endX);
      const y = Math.min(startY, endY);
      const width = Math.abs(endX - startX);
      const height = Math.abs(endY - startY);
      
      if (width < 5 || height < 5) {
        showToast('è¯·é€‰æ‹©ä¸€ä¸ªåŒºåŸŸ', 'error');
        return;
      }
      
      // åº”ç”¨é©¬èµ›å…‹
      if (invertSelection) {
        // åå‘é€‰ä¸­ï¼šå¯¹é€‰åŒºå¤–çš„åŒºåŸŸåº”ç”¨é©¬èµ›å…‹
        applyMosaicInverted(x, y, width, height, mosaicType, mosaicSize);
      } else {
        // æ­£å¸¸é€‰ä¸­ï¼šå¯¹é€‰åŒºå†…çš„åŒºåŸŸåº”ç”¨é©¬èµ›å…‹
        applyMosaic(x, y, width, height, mosaicType, mosaicSize);
      }
      
      // ä¿å­˜å½“å‰çŠ¶æ€
      currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      showToast('é©¬èµ›å…‹å·²åº”ç”¨', 'success');
    }
    
    // é©¬èµ›å…‹å¤„ç†å‡½æ•°
    function applyMosaic(x, y, width, height, type, size) {
      // ç¡®ä¿åŒºåŸŸåœ¨ç”»å¸ƒèŒƒå›´å†…
      x = Math.max(0, Math.floor(x));
      y = Math.max(0, Math.floor(y));
      width = Math.min(canvas.width - x, Math.floor(width));
      height = Math.min(canvas.height - y, Math.floor(height));
      
      if (selectionShape === 'rect') {
        // çŸ©å½¢é€‰åŒºï¼šç›´æ¥å¤„ç†æ•´ä¸ªåŒºåŸŸ
        const imageData = ctx.getImageData(x, y, width, height);
        const data = imageData.data;
        
        switch(type) {
          case 'pixelate':
            applyPixelate(data, width, height, size);
            break;
          case 'blur':
            applyBlur(data, width, height, size);
            break;
          case 'glass':
            applyGlass(data, width, height, size);
            break;
          case 'grid':
            applyGrid(data, width, height, size);
            break;
        }
        
        ctx.putImageData(imageData, x, y);
      } else if (selectionShape === 'circle') {
        // åœ†å½¢é€‰åŒºï¼šä½¿ç”¨é®ç½©
        applyMosaicWithMask(x, y, width, height, type, size, false);
      }
    }
    
    // åå‘é©¬èµ›å…‹å¤„ç†å‡½æ•°
    function applyMosaicInverted(x, y, width, height, type, size) {
      applyMosaicWithMask(x, y, width, height, type, size, true);
    }
    
    // ä½¿ç”¨é®ç½©åº”ç”¨é©¬èµ›å…‹ï¼ˆæ”¯æŒåœ†å½¢å’Œåå‘é€‰ä¸­ï¼‰
    function applyMosaicWithMask(x, y, width, height, type, size, inverted) {
      // è·å–æ•´ä¸ªç”»å¸ƒçš„å›¾åƒæ•°æ®
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      // åˆ›å»ºä¸´æ—¶canvasç”¨äºå¤„ç†é©¬èµ›å…‹
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.putImageData(imageData, 0, 0);
      
      // åº”ç”¨é©¬èµ›å…‹åˆ°æ•´ä¸ªå›¾åƒ
      const mosaicData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
      
      switch(type) {
        case 'pixelate':
          applyPixelate(mosaicData.data, canvas.width, canvas.height, size);
          break;
        case 'blur':
          applyBlur(mosaicData.data, canvas.width, canvas.height, size);
          break;
        case 'glass':
          applyGlass(mosaicData.data, canvas.width, canvas.height, size);
          break;
        case 'grid':
          applyGrid(mosaicData.data, canvas.width, canvas.height, size);
          break;
      }
      
      // è®¡ç®—é€‰åŒºå‚æ•°
      const centerX = x + width / 2;
      const centerY = y + height / 2;
      const radiusX = width / 2;
      const radiusY = height / 2;
      
      // æ ¹æ®é€‰åŒºå½¢çŠ¶å’Œåå‘é€‰ä¸­ï¼Œæ··åˆåŸå›¾å’Œé©¬èµ›å…‹å›¾
      for (let py = 0; py < canvas.height; py++) {
        for (let px = 0; px < canvas.width; px++) {
          const idx = (py * canvas.width + px) * 4;
          
          let inSelection = false;
          
          if (selectionShape === 'rect') {
            inSelection = px >= x && px < x + width && py >= y && py < y + height;
          } else if (selectionShape === 'circle') {
            // æ¤­åœ†å…¬å¼åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å†…éƒ¨
            const dx = (px - centerX) / radiusX;
            const dy = (py - centerY) / radiusY;
            inSelection = (dx * dx + dy * dy) <= 1;
          }
          
          // æ ¹æ®æ˜¯å¦åå‘é€‰ä¸­å†³å®šä½¿ç”¨å“ªä¸ªæ•°æ®
          const useMosaic = inverted ? !inSelection : inSelection;
          
          if (useMosaic) {
            data[idx] = mosaicData.data[idx];
            data[idx + 1] = mosaicData.data[idx + 1];
            data[idx + 2] = mosaicData.data[idx + 2];
          }
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
    }
    
    // åƒç´ åŒ–é©¬èµ›å…‹
    function applyPixelate(data, width, height, blockSize) {
      for (let y = 0; y < height; y += blockSize) {
        for (let x = 0; x < width; x += blockSize) {
          // è®¡ç®—å—çš„å¹³å‡é¢œè‰²
          let r = 0, g = 0, b = 0, count = 0;
          
          for (let dy = 0; dy < blockSize && y + dy < height; dy++) {
            for (let dx = 0; dx < blockSize && x + dx < width; dx++) {
              const i = ((y + dy) * width + (x + dx)) * 4;
              r += data[i];
              g += data[i + 1];
              b += data[i + 2];
              count++;
            }
          }
          
          r = Math.floor(r / count);
          g = Math.floor(g / count);
          b = Math.floor(b / count);
          
          // åº”ç”¨å¹³å‡é¢œè‰²åˆ°æ•´ä¸ªå—
          for (let dy = 0; dy < blockSize && y + dy < height; dy++) {
            for (let dx = 0; dx < blockSize && x + dx < width; dx++) {
              const i = ((y + dy) * width + (x + dx)) * 4;
              data[i] = r;
              data[i + 1] = g;
              data[i + 2] = b;
            }
          }
        }
      }
    }
    
    // æ¨¡ç³Šé©¬èµ›å…‹
    function applyBlur(data, width, height, radius) {
      const tempData = new Uint8ClampedArray(data);
      const r = Math.floor(radius / 2);
      
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let rSum = 0, gSum = 0, bSum = 0, count = 0;
          
          for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
              const nx = x + dx;
              const ny = y + dy;
              
              if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                const i = (ny * width + nx) * 4;
                rSum += tempData[i];
                gSum += tempData[i + 1];
                bSum += tempData[i + 2];
                count++;
              }
            }
          }
          
          const i = (y * width + x) * 4;
          data[i] = Math.floor(rSum / count);
          data[i + 1] = Math.floor(gSum / count);
          data[i + 2] = Math.floor(bSum / count);
        }
      }
    }
    
    // æ¯›ç»ç’ƒé©¬èµ›å…‹
    function applyGlass(data, width, height, intensity) {
      const tempData = new Uint8ClampedArray(data);
      
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          // éšæœºåç§»
          const offsetX = Math.floor((Math.random() - 0.5) * intensity);
          const offsetY = Math.floor((Math.random() - 0.5) * intensity);
          
          let nx = x + offsetX;
          let ny = y + offsetY;
          
          // ç¡®ä¿åœ¨èŒƒå›´å†…
          nx = Math.max(0, Math.min(width - 1, nx));
          ny = Math.max(0, Math.min(height - 1, ny));
          
          const srcI = (ny * width + nx) * 4;
          const dstI = (y * width + x) * 4;
          
          data[dstI] = tempData[srcI];
          data[dstI + 1] = tempData[srcI + 1];
          data[dstI + 2] = tempData[srcI + 2];
        }
      }
    }
    
    // ç½‘æ ¼é©¬èµ›å…‹
    function applyGrid(data, width, height, gridSize) {
      for (let y = 0; y < height; y += gridSize) {
        for (let x = 0; x < width; x += gridSize) {
          // è®¡ç®—å—çš„å¹³å‡é¢œè‰²
          let r = 0, g = 0, b = 0, count = 0;
          
          for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
            for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
              const i = ((y + dy) * width + (x + dx)) * 4;
              r += data[i];
              g += data[i + 1];
              b += data[i + 2];
              count++;
            }
          }
          
          r = Math.floor(r / count);
          g = Math.floor(g / count);
          b = Math.floor(b / count);
          
          // åº”ç”¨é¢œè‰²å¹¶æ·»åŠ ç½‘æ ¼çº¿
          for (let dy = 0; dy < gridSize && y + dy < height; dy++) {
            for (let dx = 0; dx < gridSize && x + dx < width; dx++) {
              const i = ((y + dy) * width + (x + dx)) * 4;
              
              // ç½‘æ ¼è¾¹ç¼˜ä½¿ç”¨æ·±è‰²
              if (dx === 0 || dy === 0 || dx === gridSize - 1 || dy === gridSize - 1) {
                data[i] = Math.floor(r * 0.5);
                data[i + 1] = Math.floor(g * 0.5);
                data[i + 2] = Math.floor(b * 0.5);
              } else {
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
              }
            }
          }
        }
      }
    }
    
    // é‡ç½®å›¾ç‰‡
    function resetImage() {
      if (!originalImage) return;
      
      ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
      currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      showToast('å›¾ç‰‡å·²é‡ç½®', 'success');
    }
    
    // ä¸‹è½½å›¾ç‰‡
    function downloadImage() {
      if (!originalImage) {
        showToast('è¯·å…ˆä¸Šä¼ å›¾ç‰‡', 'error');
        return;
      }
      
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `mosaic_${Date.now()}.png`;
        a.click();
        URL.revokeObjectURL(url);
        
        showToast('å›¾ç‰‡ä¸‹è½½æˆåŠŸ', 'success');
      }, 'image/png');
    }
    
    // Toast æç¤º
    function showToast(message, type = 'success') {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast ${type}`;
      toast.classList.add('show');
      
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    }
  </script>
</body>
</html>