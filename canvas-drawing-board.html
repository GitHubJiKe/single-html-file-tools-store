<!-- Canvas åœ¨çº¿ç”»å›¾å·¥å…·ï¼ˆå•æ–‡ä»¶HTMLå®ç°ï¼Œæ— éœ€æ„å»ºæ­¥éª¤ï¼‰-->
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Canvas åœ¨çº¿ç”»å›¾å·¥å…·</title>
  <link rel="icon" type="image/x-icon" href="./favicon.ico">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: system-ui, sans-serif;
      background: #f5f5f5;
      padding: 10px;
      overflow-x: hidden;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.1);
    }
    h1 {
      font-size: 22px;
      margin-bottom: 16px;
      color: #333;
      text-align: center;
    }
    
    /* å·¥å…·æ  */
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 16px;
      padding: 12px;
      background: #f9f9f9;
      border-radius: 8px;
      align-items: center;
    }
    .tool-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .tool-group label {
      font-size: 14px;
      color: #666;
      white-space: nowrap;
    }
    .color-picker {
      width: 50px;
      height: 40px;
      border: 2px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
    }
    .size-input {
      width: 60px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
    }
    
    /* æŒ‰é’®æ ·å¼ */
    button {
      padding: 10px 16px;
      font-size: 14px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
      white-space: nowrap;
    }
    .btn-primary {
      background: #006aff;
      color: white;
    }
    .btn-primary:hover { background: #0056cc; }
    .btn-primary:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .btn-secondary {
      background: #6c757d;
      color: white;
    }
    .btn-secondary:hover { background: #5a6268; }
    .btn-danger {
      background: #dc3545;
      color: white;
    }
    .btn-danger:hover { background: #c82333; }
    .btn-success {
      background: #28a745;
      color: white;
    }
    .btn-success:hover { background: #218838; }
    
    .btn-tool {
      background: white;
      border: 2px solid #ddd;
      color: #333;
    }
    .btn-tool:hover {
      border-color: #006aff;
      color: #006aff;
    }
    .btn-tool.active {
      background: #006aff;
      color: white;
      border-color: #006aff;
    }
    
    .btn-sm {
      padding: 6px 12px;
      font-size: 13px;
    }
    
    .file-input {
      display: none;
    }
    
    /* å›¾ç‰‡è°ƒæ•´æ§åˆ¶é¢æ¿ */
    .image-control-panel {
      background: #fff3cd;
      border: 2px solid #ffc107;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
    }
    .control-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      font-weight: 600;
      color: #856404;
    }
    .control-header span {
      flex: 1;
    }
    .control-body {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .control-item {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .control-item label {
      font-size: 14px;
      color: #856404;
      min-width: 50px;
    }
    .control-item input[type="range"] {
      flex: 1;
    }
    .control-item span {
      min-width: 50px;
      text-align: right;
      font-weight: 600;
      color: #856404;
    }
    .control-tips {
      font-size: 13px;
      color: #856404;
      padding: 8px;
      background: rgba(255, 193, 7, 0.1);
      border-radius: 4px;
    }
    
    /* Canvas å®¹å™¨ */
    .canvas-container {
      display: flex;
      justify-content: center;
      background: #f9f9f9;
      padding: 20px;
      border-radius: 8px;
      overflow: auto;
    }
    #drawCanvas {
      border: 2px solid #ddd;
      cursor: crosshair;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      touch-action: none;
    }
    #drawCanvas.eraser {
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="2" y="2" width="20" height="20" fill="white" stroke="black" stroke-width="2"/></svg>') 12 12, auto;
    }
    
    /* çŠ¶æ€æç¤º */
    .status-message {
      padding: 10px;
      border-radius: 6px;
      margin-top: 12px;
      font-size: 14px;
      display: none;
      text-align: center;
    }
    .status-message.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .status-message.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    
    /* å“åº”å¼ */
    @media (max-width: 768px) {
      body { padding: 5px; }
      .container { padding: 12px; }
      h1 { font-size: 18px; margin-bottom: 12px; }
      .toolbar {
        gap: 8px;
        padding: 10px;
      }
      .tool-group {
        gap: 6px;
      }
      .tool-group label {
        font-size: 13px;
      }
      button {
        padding: 8px 12px;
        font-size: 13px;
      }
      .color-picker {
        width: 40px;
        height: 36px;
      }
      .size-input {
        width: 50px;
        padding: 6px;
        font-size: 13px;
      }
      .canvas-container {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ¨ Canvas åœ¨çº¿ç”»å›¾å·¥å…·</h1>
    
    <!-- å·¥å…·æ  -->
    <div class="toolbar">
      <!-- å·¥å…·é€‰æ‹© -->
      <div class="tool-group">
        <button id="penBtn" class="btn-tool active" title="ç”»ç¬”">âœï¸ ç”»ç¬”</button>
        <button id="eraserBtn" class="btn-tool" title="æ©¡çš®æ“¦">ğŸ§¹ æ©¡çš®æ“¦</button>
      </div>
      
      <!-- é¢œè‰²é€‰æ‹© -->
      <div class="tool-group">
        <label>èƒŒæ™¯è‰²:</label>
        <input type="color" id="bgColor" class="color-picker" value="#ffffff">
      </div>
      
      <div class="tool-group">
        <label>ç”»ç¬”è‰²:</label>
        <input type="color" id="penColor" class="color-picker" value="#000000">
      </div>
      
      <!-- ç”»ç¬”ç²—ç»† -->
      <div class="tool-group">
        <label>ç²—ç»†:</label>
        <input type="number" id="penSize" class="size-input" min="1" max="50" value="3">
        <span id="penSizeDisplay">3px</span>
      </div>
      
      <!-- æ“ä½œæŒ‰é’® -->
      <div class="tool-group">
        <button id="undoBtn" class="btn-secondary" title="æ’¤é”€ (Ctrl+Z)" disabled>â†¶ æ’¤é”€</button>
        <button id="redoBtn" class="btn-secondary" title="é‡åš (Ctrl+Y)" disabled>â†· é‡åš</button>
      </div>
      
      <div class="tool-group">
        <button id="uploadImageBtn" class="btn-primary" title="ä¸Šä¼ å›¾ç‰‡">ğŸ“· ä¸Šä¼ å›¾ç‰‡</button>
        <input type="file" id="uploadImageInput" class="file-input" accept="image/*">
      </div>
      
      <div class="tool-group">
        <button id="clearBtn" class="btn-danger" title="æ¸…ç©ºç”»å¸ƒ">ğŸ—‘ï¸ æ¸…ç©º</button>
        <button id="downloadBtn" class="btn-success" title="ä¸‹è½½å›¾ç‰‡">ğŸ’¾ ä¸‹è½½</button>
      </div>
    </div>
    
    <!-- å›¾ç‰‡è°ƒæ•´æ§åˆ¶é¢æ¿ -->
    <div id="imageControlPanel" class="image-control-panel" style="display: none;">
      <div class="control-header">
        <span>ğŸ“ è°ƒæ•´å›¾ç‰‡å¤§å°å’Œä½ç½®</span>
        <button id="confirmImageBtn" class="btn-success btn-sm">âœ“ ç¡®è®¤</button>
        <button id="cancelImageBtn" class="btn-secondary btn-sm">âœ• å–æ¶ˆ</button>
      </div>
      <div class="control-body">
        <div class="control-item">
          <label>ç¼©æ”¾:</label>
          <input type="range" id="imageScale" min="10" max="200" value="100" step="5">
          <span id="imageScaleValue">100%</span>
        </div>
        <div class="control-tips">
          ğŸ’¡ æ‹–åŠ¨å›¾ç‰‡å¯ç§»åŠ¨ä½ç½®ï¼Œæ‹–åŠ¨æ»‘å—å¯è°ƒæ•´å¤§å°
        </div>
      </div>
    </div>
    
    <!-- Canvas ç”»å¸ƒ -->
    <div class="canvas-container">
      <canvas id="drawCanvas" width="800" height="600"></canvas>
    </div>
    
    <!-- çŠ¶æ€æ¶ˆæ¯ -->
    <div class="status-message" id="statusMessage"></div>
  </div>

  <script>
    // å…¨å±€å˜é‡
    const canvas = document.getElementById('drawCanvas');
    const ctx = canvas.getContext('2d');
    const bgColorInput = document.getElementById('bgColor');
    const penColorInput = document.getElementById('penColor');
    const penSizeInput = document.getElementById('penSize');
    const penSizeDisplay = document.getElementById('penSizeDisplay');
    const penBtn = document.getElementById('penBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusMessage = document.getElementById('statusMessage');
    const uploadImageBtn = document.getElementById('uploadImageBtn');
    const uploadImageInput = document.getElementById('uploadImageInput');
    const imageControlPanel = document.getElementById('imageControlPanel');
    const imageScale = document.getElementById('imageScale');
    const imageScaleValue = document.getElementById('imageScaleValue');
    const confirmImageBtn = document.getElementById('confirmImageBtn');
    const cancelImageBtn = document.getElementById('cancelImageBtn');
    
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let currentTool = 'pen'; // 'pen' or 'eraser'
    
    // å†å²è®°å½•ç®¡ç†
    let history = [];
    let historyStep = -1;
    const MAX_HISTORY = 50;
    
    // å›¾ç‰‡ä¸Šä¼ ç›¸å…³
    let uploadedImage = null;
    let imageX = 0;
    let imageY = 0;
    let imageWidth = 0;
    let imageHeight = 0;
    let originalImageWidth = 0;
    let originalImageHeight = 0;
    let isDraggingImage = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let isImageMode = false;
    let tempCanvasState = null;
    
    // åˆå§‹åŒ–ç”»å¸ƒ
    function initCanvas() {
      // è®¾ç½®ç”»å¸ƒå°ºå¯¸ï¼ˆå“åº”å¼ï¼‰
      const containerWidth = canvas.parentElement.clientWidth - 40;
      const maxWidth = 800;
      const maxHeight = 600;
      
      if (window.innerWidth <= 768) {
        canvas.width = Math.min(containerWidth, maxWidth);
        canvas.height = Math.min(canvas.width * 0.75, maxHeight);
      } else {
        canvas.width = maxWidth;
        canvas.height = maxHeight;
      }
      
      // å¡«å……èƒŒæ™¯è‰²
      ctx.fillStyle = bgColorInput.value;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // ä¿å­˜åˆå§‹çŠ¶æ€
      saveState();
    }
    
    // ä¿å­˜ç”»å¸ƒçŠ¶æ€åˆ°å†å²è®°å½•
    function saveState() {
      // ç§»é™¤å½“å‰æ­¥éª¤ä¹‹åçš„æ‰€æœ‰å†å²è®°å½•
      if (historyStep < history.length - 1) {
        history = history.slice(0, historyStep + 1);
      }
      
      // ä¿å­˜å½“å‰çŠ¶æ€
      const imageData = canvas.toDataURL();
      history.push(imageData);
      
      // é™åˆ¶å†å²è®°å½•æ•°é‡
      if (history.length > MAX_HISTORY) {
        history.shift();
      } else {
        historyStep++;
      }
      
      updateUndoRedoButtons();
    }
    
    // æ¢å¤ç”»å¸ƒçŠ¶æ€
    function restoreState(index) {
      if (index >= 0 && index < history.length) {
        const img = new Image();
        img.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = history[index];
        historyStep = index;
        updateUndoRedoButtons();
      }
    }
    
    // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
    function updateUndoRedoButtons() {
      undoBtn.disabled = historyStep <= 0;
      redoBtn.disabled = historyStep >= history.length - 1;
    }
    
    // æ’¤é”€
    function undo() {
      if (historyStep > 0) {
        restoreState(historyStep - 1);
      }
    }
    
    // é‡åš
    function redo() {
      if (historyStep < history.length - 1) {
        restoreState(historyStep + 1);
      }
    }
    
    // ç»˜ç”»åŠŸèƒ½
    function startDrawing(e) {
      if (isImageMode) return; // å›¾ç‰‡æ¨¡å¼ä¸‹ç¦ç”¨ç»˜ç”»
      
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      if (e.type.includes('touch')) {
        lastX = (e.touches[0].clientX - rect.left) * scaleX;
        lastY = (e.touches[0].clientY - rect.top) * scaleY;
      } else {
        lastX = (e.clientX - rect.left) * scaleX;
        lastY = (e.clientY - rect.top) * scaleY;
      }
    }
    
    function draw(e) {
      if (!isDrawing || isImageMode) return; // å›¾ç‰‡æ¨¡å¼ä¸‹ç¦ç”¨ç»˜ç”»
      
      e.preventDefault();
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      let x, y;
      if (e.type.includes('touch')) {
        x = (e.touches[0].clientX - rect.left) * scaleX;
        y = (e.touches[0].clientY - rect.top) * scaleY;
      } else {
        x = (e.clientX - rect.left) * scaleX;
        y = (e.clientY - rect.top) * scaleY;
      }
      
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
      
      if (currentTool === 'pen') {
        ctx.strokeStyle = penColorInput.value;
        ctx.globalCompositeOperation = 'source-over';
      } else if (currentTool === 'eraser') {
        ctx.strokeStyle = bgColorInput.value;
        ctx.globalCompositeOperation = 'source-over';
      }
      
      ctx.lineWidth = penSizeInput.value;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();
      
      lastX = x;
      lastY = y;
    }
    
    function stopDrawing() {
      if (isDrawing) {
        isDrawing = false;
        saveState();
      }
    }
    
    // äº‹ä»¶ç›‘å¬
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    
    // è§¦æ‘¸äº‹ä»¶
    canvas.addEventListener('touchstart', startDrawing, { passive: false });
    canvas.addEventListener('touchmove', draw, { passive: false });
    canvas.addEventListener('touchend', stopDrawing);
    canvas.addEventListener('touchcancel', stopDrawing);
    
    // å·¥å…·åˆ‡æ¢
    penBtn.addEventListener('click', function() {
      currentTool = 'pen';
      penBtn.classList.add('active');
      eraserBtn.classList.remove('active');
      canvas.classList.remove('eraser');
    });
    
    eraserBtn.addEventListener('click', function() {
      currentTool = 'eraser';
      eraserBtn.classList.add('active');
      penBtn.classList.remove('active');
      canvas.classList.add('eraser');
    });
    
    // èƒŒæ™¯è‰²å˜æ›´
    bgColorInput.addEventListener('change', function() {
      // ä¿å­˜å½“å‰ç”»å¸ƒå†…å®¹ä¸ºå›¾ç‰‡
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(canvas, 0, 0);
      
      // å¡«å……æ–°èƒŒæ™¯è‰²
      ctx.fillStyle = this.value;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // æ¢å¤ç”»å¸ƒå†…å®¹
    //   ctx.drawImage(tempCanvas, 0, 0);
      
      saveState();
      showStatus('èƒŒæ™¯è‰²å·²æ›´æ–°', 'success');
    });
    
    // ç”»ç¬”ç²—ç»†æ˜¾ç¤º
    penSizeInput.addEventListener('input', function() {
      penSizeDisplay.textContent = this.value + 'px';
    });
    
    // æ’¤é”€/é‡åš
    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
    
    // é”®ç›˜å¿«æ·é”®
    document.addEventListener('keydown', function(e) {
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z' || e.key === 'Z') {
          e.preventDefault();
          if (e.shiftKey) {
            redo();
          } else {
            undo();
          }
        } else if (e.key === 'y' || e.key === 'Y') {
          e.preventDefault();
          redo();
        }
      }
    });
    
    // æ¸…ç©ºç”»å¸ƒ
    clearBtn.addEventListener('click', function() {
      if (confirm('ç¡®å®šè¦æ¸…ç©ºç”»å¸ƒå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
        ctx.fillStyle = bgColorInput.value;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        saveState();
        showStatus('ç”»å¸ƒå·²æ¸…ç©º', 'info');
      }
    });
    
    // ä¸‹è½½å›¾ç‰‡
    downloadBtn.addEventListener('click', function() {
      try {
        const dataURL = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataURL;
        a.download = `drawing-${Date.now()}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        showStatus('å›¾ç‰‡å·²ä¸‹è½½', 'success');
      } catch (error) {
        showStatus('ä¸‹è½½å¤±è´¥ï¼š' + error.message, 'error');
      }
    });
    
    // ä¸Šä¼ å›¾ç‰‡
    uploadImageBtn.addEventListener('click', function() {
      uploadImageInput.click();
    });
    
    uploadImageInput.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          // ä¿å­˜å½“å‰ç”»å¸ƒçŠ¶æ€
          tempCanvasState = canvas.toDataURL();
          
          // è®¾ç½®å›¾ç‰‡
          uploadedImage = img;
          originalImageWidth = img.width;
          originalImageHeight = img.height;
          
          // è®¡ç®—åˆå§‹ä½ç½®å’Œå¤§å°ï¼ˆå±…ä¸­æ˜¾ç¤ºï¼Œé€‚åº”ç”»å¸ƒï¼‰
          const scale = Math.min(canvas.width / img.width, canvas.height / img.height, 1);
          imageWidth = img.width * scale;
          imageHeight = img.height * scale;
          imageX = (canvas.width - imageWidth) / 2;
          imageY = (canvas.height - imageHeight) / 2;
          
          // è¿›å…¥å›¾ç‰‡è°ƒæ•´æ¨¡å¼
          isImageMode = true;
          imageControlPanel.style.display = 'block';
          imageScale.value = 100;
          imageScaleValue.textContent = '100%';
          
          // ç¦ç”¨ç»˜ç”»åŠŸèƒ½
          canvas.style.cursor = 'move';
          
          // ç»˜åˆ¶å›¾ç‰‡
          drawImageOnCanvas();
          
          showStatus('å›¾ç‰‡å·²åŠ è½½ï¼Œè¯·è°ƒæ•´ä½ç½®å’Œå¤§å°', 'info');
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
      this.value = '';
    });
    
    // ç»˜åˆ¶å›¾ç‰‡åˆ°ç”»å¸ƒ
    function drawImageOnCanvas() {
      if (!uploadedImage) return;
      
      // æ¢å¤ç”»å¸ƒçŠ¶æ€
      if (tempCanvasState) {
        const img = new Image();
        img.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          
          // ç»˜åˆ¶ä¸Šä¼ çš„å›¾ç‰‡
          ctx.drawImage(uploadedImage, imageX, imageY, imageWidth, imageHeight);
          
          // ç»˜åˆ¶è¾¹æ¡†å’Œæ§åˆ¶ç‚¹
          ctx.strokeStyle = '#006aff';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(imageX, imageY, imageWidth, imageHeight);
          ctx.setLineDash([]);
        };
        img.src = tempCanvasState;
      }
    }
    
    // å›¾ç‰‡ç¼©æ”¾
    imageScale.addEventListener('input', function() {
      const scale = this.value / 100;
      imageScaleValue.textContent = this.value + '%';
      
      // è®¡ç®—æ–°çš„å®½é«˜ï¼ˆä¿æŒä¸­å¿ƒç‚¹ä¸å˜ï¼‰
      const centerX = imageX + imageWidth / 2;
      const centerY = imageY + imageHeight / 2;
      
      imageWidth = originalImageWidth * scale * Math.min(canvas.width / originalImageWidth, canvas.height / originalImageHeight, 1);
      imageHeight = originalImageHeight * scale * Math.min(canvas.width / originalImageWidth, canvas.height / originalImageHeight, 1);
      
      imageX = centerX - imageWidth / 2;
      imageY = centerY - imageHeight / 2;
      
      drawImageOnCanvas();
    });
    
    // å›¾ç‰‡æ‹–æ‹½
    canvas.addEventListener('mousedown', function(e) {
      if (!isImageMode) return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      
      // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨å›¾ç‰‡ä¸Š
      if (x >= imageX && x <= imageX + imageWidth && y >= imageY && y <= imageY + imageHeight) {
        isDraggingImage = true;
        dragStartX = x - imageX;
        dragStartY = y - imageY;
      }
    });
    
    canvas.addEventListener('mousemove', function(e) {
      if (!isImageMode || !isDraggingImage) return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      
      imageX = x - dragStartX;
      imageY = y - dragStartY;
      
      drawImageOnCanvas();
    });
    
    canvas.addEventListener('mouseup', function() {
      if (isImageMode) {
        isDraggingImage = false;
      }
    });
    
    // è§¦æ‘¸æ”¯æŒï¼ˆå›¾ç‰‡æ‹–æ‹½ï¼‰
    canvas.addEventListener('touchstart', function(e) {
      if (!isImageMode) return;
      
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.touches[0].clientX - rect.left) * scaleX;
      const y = (e.touches[0].clientY - rect.top) * scaleY;
      
      if (x >= imageX && x <= imageX + imageWidth && y >= imageY && y <= imageY + imageHeight) {
        isDraggingImage = true;
        dragStartX = x - imageX;
        dragStartY = y - imageY;
      }
    }, { passive: false });
    
    canvas.addEventListener('touchmove', function(e) {
      if (!isImageMode || !isDraggingImage) return;
      
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.touches[0].clientX - rect.left) * scaleX;
      const y = (e.touches[0].clientY - rect.top) * scaleY;
      
      imageX = x - dragStartX;
      imageY = y - dragStartY;
      
      drawImageOnCanvas();
    }, { passive: false });
    
    canvas.addEventListener('touchend', function() {
      if (isImageMode) {
        isDraggingImage = false;
      }
    });
    
    // ç¡®è®¤å›¾ç‰‡
    confirmImageBtn.addEventListener('click', function() {
      if (!uploadedImage) return;
      
      // å°†å›¾ç‰‡ç»˜åˆ¶åˆ°ç”»å¸ƒ
      const img = new Image();
      img.onload = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
        ctx.drawImage(uploadedImage, imageX, imageY, imageWidth, imageHeight);
        
        // é€€å‡ºå›¾ç‰‡æ¨¡å¼
        exitImageMode();
        
        // ä¿å­˜çŠ¶æ€
        saveState();
        
        showStatus('å›¾ç‰‡å·²æ·»åŠ åˆ°ç”»å¸ƒ', 'success');
      };
      img.src = tempCanvasState;
    });
    
    // å–æ¶ˆå›¾ç‰‡
    cancelImageBtn.addEventListener('click', function() {
      if (!tempCanvasState) return;
      
      // æ¢å¤ç”»å¸ƒçŠ¶æ€
      const img = new Image();
      img.onload = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
      };
      img.src = tempCanvasState;
      
      // é€€å‡ºå›¾ç‰‡æ¨¡å¼
      exitImageMode();
      
      showStatus('å·²å–æ¶ˆå›¾ç‰‡ä¸Šä¼ ', 'info');
    });
    
    // é€€å‡ºå›¾ç‰‡æ¨¡å¼
    function exitImageMode() {
      isImageMode = false;
      uploadedImage = null;
      tempCanvasState = null;
      imageControlPanel.style.display = 'none';
      canvas.style.cursor = currentTool === 'eraser' ? 'url(...)' : 'crosshair';
      if (currentTool === 'eraser') {
        canvas.classList.add('eraser');
      }
    }
    
    // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
    function showStatus(message, type) {
      statusMessage.textContent = message;
      statusMessage.className = `status-message ${type}`;
      statusMessage.style.display = 'block';
      
      setTimeout(() => {
        statusMessage.style.display = 'none';
      }, 3000);
    }
    
    // çª—å£å¤§å°å˜åŒ–æ—¶è°ƒæ•´ç”»å¸ƒ
    let resizeTimeout;
    window.addEventListener('resize', function() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        // ä¿å­˜å½“å‰ç”»å¸ƒå†…å®¹
        const imageData = canvas.toDataURL();
        
        // é‡æ–°åˆå§‹åŒ–ç”»å¸ƒ
        initCanvas();
        
        // æ¢å¤ç”»å¸ƒå†…å®¹
        const img = new Image();
        img.onload = function() {
          ctx.drawImage(img, 0, 0);
        };
        img.src = imageData;
      }, 300);
    });
    
    // åˆå§‹åŒ–
    initCanvas();
  </script>

  <!--
    å·¥å…·å…ƒä¿¡æ¯ï¼š
    æ ¸å¿ƒæç¤ºè¯ï¼šåŸºäºSimon Willisonå•æ–‡ä»¶å“²å­¦å¼€å‘HTMLå·¥å…·ï¼Œè¦æ±‚ï¼š1. å•ä¸ªHTMLæ–‡ä»¶ï¼Œå†…åµŒJS/CSSï¼Œæ— æ„å»ºæ­¥éª¤ï¼ŒNo Reactï¼›2. æ ¸å¿ƒåŠŸèƒ½ï¼šCanvasç»˜ç”»ã€æ’¤é”€é‡åšã€æ©¡çš®æ“¦ã€ä¸‹è½½å›¾ç‰‡ï¼›3. ä¾èµ–ï¼šæ— ä¾èµ–ï¼Œä½¿ç”¨åŸç”ŸCanvas APIï¼›4. äº¤äº’ï¼šç”»ç¬”/æ©¡çš®æ“¦åˆ‡æ¢ã€é¢œè‰²é€‰æ‹©ã€ç²—ç»†è°ƒèŠ‚ã€æ’¤é”€é‡åšã€æ¸…ç©ºä¸‹è½½ï¼›5. çŠ¶æ€å­˜å‚¨ï¼šå†…å­˜ä¸­ç®¡ç†å†å²è®°å½•æ•°ç»„ã€‚
    ä¾èµ–CDNï¼šæ— 
    æœ€åä¿®æ”¹ï¼š2025-12-22
  -->
</body>
</html>